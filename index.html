<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Flappy Bird - High Quality 2D Enhanced</title>
<style>
  body, html {
    margin: 0; padding: 0; height: 100%; overflow: hidden;
    background: linear-gradient(to bottom, #87CEEB 0%, #98FB98 100%);
    display: flex; justify-content: center; align-items: center;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    user-select: none;
  }
  #gameCanvas {
    border-radius: 15px;
    box-shadow: 0 10px 25px rgba(0,0,0,0.35);
    background: transparent;
    width: 100vw;
    height: 100vh;
    max-width: 100vw;
    max-height: 100vh;
  }
  .score {
    position: absolute;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    color: #fff;
    font-weight: 900;
    font-size: 36px;
    text-shadow: 2px 2px 6px #000a;
    user-select: none;
    pointer-events: none;
    z-index: 5;
  }
  .instructions {
    position: fixed;
    bottom: 10px;
    left: 50%;
    transform: translateX(-50%);
    color: #224422cc;
    font-weight: 700;
    text-shadow: 1px 1px 3px #fff8;
    font-size: 14px;
    user-select: none;
    z-index: 5;
  }
  /* Start and Game Over Screens */
  .overlay-screen {
    position: fixed;
    top: 0; left: 0;
    width: 100vw; height: 100vh;
    background: rgba(30,40,60,0.76);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 10;
    transition: opacity 0.2s;
  }
  .hidden { display: none; }

  .overlay-title {
    color: #fff;
    font-size: 40px;
    font-weight: bold;
    margin-bottom: 20px;
    letter-spacing: 2px;
    text-shadow: 2px 2px 10px #000a;
  }
  .overlay-by {
    color: #00e5d7;
    font-size: 19px;
    margin-bottom: 18px;
    text-shadow: 1px 1px 6px #0006;
  }
  .overlay-btn {
    font-size: 22px;
    font-weight: bold;
    background: #00c4cc;
    border: none;
    border-radius: 10px;
    color: #fff;
    padding: 14px 44px;
    cursor: pointer;
    margin-top: 22px;
    letter-spacing: 1.2px;
    box-shadow: 0 3px 20px #0004;
    transition: background 0.2s;
  }
  .overlay-btn:hover {
    background: #008891;
  }
  .overlay-score-label {
    color: #f1e47b;
    font-size: 19px;
    margin-top: 16px;
    margin-bottom: 3px;
    letter-spacing: 1px;
    font-weight: bold;
  }
  .overlay-score-value {
    color: #fff;
    font-size: 29px;
    font-weight: bold;
    text-shadow: 2px 2px 6px #000a;
  }
</style>
</head>
<body>

<div class="score" id="score">0</div>
<canvas id="gameCanvas"></canvas>
<div class="instructions">Tap/click/space to flap. Press R to restart.</div>

<!-- Start Screen -->
<div class="overlay-screen" id="startScreen">
  <div class="overlay-title">Flappy Bird</div>
  <div class="overlay-by">made by Alsari</div>
  <button class="overlay-btn" id="startBtn">Press to Start</button>
  <div class="overlay-score-label">Highest Score</div>
  <div class="overlay-score-value" id="highestScoreStart">0</div>
</div>

<!-- Game Over Screen -->
<div class="overlay-screen hidden" id="gameOverScreen">
  <div class="overlay-title" style="color:#f55;">Game Over</div>
  <div class="overlay-score-label">Your Score</div>
  <div class="overlay-score-value" id="yourScore">0</div>
  <div class="overlay-score-label">Highest Score</div>
  <div class="overlay-score-value" id="highestScoreEnd">0</div>
  <button class="overlay-btn" id="restartBtn">Press to Restart</button>
</div>

<script>
// --- Setup ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');

// Overlay screens
const startScreen = document.getElementById('startScreen');
const gameOverScreen = document.getElementById('gameOverScreen');
const highestScoreStart = document.getElementById('highestScoreStart');
const highestScoreEnd = document.getElementById('highestScoreEnd');
const yourScore = document.getElementById('yourScore');
const startBtn = document.getElementById('startBtn');
const restartBtn = document.getElementById('restartBtn');

let highestScore = Number(localStorage.getItem('flappy_highscore') || 0);

function updateHighScoreDisplay() {
  highestScoreStart.textContent = highestScore;
  highestScoreEnd.textContent = highestScore;
}

updateHighScoreDisplay();

// Set canvas size to match screen
function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

// Audio setup
let audioCtx;
let soundOn = true;
function initAudio() {
  try {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  } catch {
    soundOn = false;
  }
}
initAudio();

// Play sound utility
function playSound(freq, duration, type = 'triangle', volume = 0.12) {
  if (!soundOn || !audioCtx) return;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = type;
  osc.frequency.value = freq;
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  gain.gain.setValueAtTime(volume, audioCtx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
  osc.start(audioCtx.currentTime);
  osc.stop(audioCtx.currentTime + duration);
}

// --- Variables ---
let gameState = 'start';     // start | playing | gameOver
let score = 0;
let frames = 0;

const bird = {
  x: 80,
  y: 300,
  width: 48,
  height: 36,
  velY: 0,
  gravity: 0.6,
  jumpForce: -11,
  rotation: 0,
  wingFrame: 0,
  wingSpeed: 0.25
};

const pipeWidth = 70;
const pipeGap = 180;
const pipeSpeed = 3;
let pipes = [];

const groundHeight = 80;
let groundOffset = 0;

const clouds = [];
const maxClouds = 6;

// Particle system
const particles = [];

function randRange(min, max) {
  return Math.random() * (max - min) + min;
}

// --- Init Clouds ---
function initClouds() {
  clouds.length = 0;
  for (let i=0; i<maxClouds; i++) {
    clouds.push({
      x: randRange(0, canvas.width * 2),
      y: randRange(40, 130),
      radius: randRange(30, 55),
      speed: randRange(0.3, 0.8)
    });
  }
}

// --- Particle ---
function createParticle(x,y,color) {
  particles.push({
    x, y,
    vx: randRange(-3,3),
    vy: randRange(-4,-1),
    size: randRange(2,6),
    life: 30,
    maxLife: 30,
    color
  });
}

function updateParticles() {
  for(let i=particles.length-1; i>=0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.25; // gravity effect
    p.life--;
    if(p.life<=0) particles.splice(i,1);
  }
}

function drawParticles() {
  particles.forEach(p => {
    ctx.save();
    ctx.globalAlpha = p.life/p.maxLife;
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size*(p.life/p.maxLife), 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  });
}

// --- Pipes ---
function addPipe() {
  const minPipeHeight = 100;
  const maxPipeHeight = canvas.height - groundHeight - pipeGap - minPipeHeight;
  const topHeight = randRange(minPipeHeight, maxPipeHeight);
  pipes.push({
    x: canvas.width,
    topHeight,
    bottomY: topHeight + pipeGap,
    bottomHeight: canvas.height - groundHeight - (topHeight + pipeGap),
    passed: false,
    highlight: false
  });
}

function resetGame() {
  pipes = [];
  score = 0;
  frames = 0;
  bird.y = 300;
  bird.velY = 0;
  bird.rotation = 0;
  bird.wingFrame = 0;
  gameState = 'playing';
  groundOffset = 0;
  initClouds();
  addPipe();
  updateScore();
  scoreEl.style.visibility = "visible";
  gameOverScreen.classList.add('hidden');
  updateHighScoreDisplay();
}

function updateScore() {
  scoreEl.textContent = score;
}

// --- Game Logic ---
function flap() {
  if(gameState !== 'playing') return;
  bird.velY = bird.jumpForce;
  playFlapSound();
  for(let i=0; i<6; i++) {
    createParticle(bird.x + bird.width/2, bird.y + bird.height, '#87CEEB');
  }
}

function playFlapSound() {
  playSound(350, 0.1, 'triangle', 0.2);
}

function playScoreSound() {
  const notes = [523, 659, 784];
  notes.forEach((n,i) => setTimeout(() => playSound(n, 0.15, 'triangle', 0.15), i * 60));
}

function playHitSound() {
  playSound(200, 0.1, 'square', 0.3);
}

function playGameOverSound() {
  playSound(400, 0.4, 'sawtooth', 0.25);
}

function checkCollisions() {
  // Ground collision
  if(bird.y + bird.height >= canvas.height - groundHeight) {
    playHitSound();
    endGame();
  }
  if(bird.y <= 0) {
    playHitSound();
    endGame();
  }
  // Pipes collision
  for(const p of pipes) {
    if(bird.x + bird.width > p.x && bird.x < p.x + pipeWidth) {
      if(bird.y < p.topHeight || bird.y + bird.height > p.bottomY) {
        playHitSound();
        endGame();
      }
    }
  }
}

function endGame() {
  gameState = 'gameOver';
  playGameOverSound();
  for(let i=0; i<20; i++) {
    createParticle(bird.x + bird.width/2, bird.y + bird.height/2, '#FF5555');
  }
  if(score > highestScore) {
    highestScore = score;
    localStorage.setItem('flappy_highscore', highestScore);
  }
  yourScore.textContent = score;
  highestScoreEnd.textContent = highestScore;
  setTimeout(()=>{
    gameOverScreen.classList.remove('hidden');
    scoreEl.style.visibility = "hidden";
  }, 600);
}

function update() {
  if(gameState !== 'playing') return;

  frames++;
  groundOffset -= pipeSpeed;
  bird.velY += bird.gravity;
  bird.y += bird.velY;

  bird.rotation = Math.min(Math.max(bird.velY * 0.08, -0.6), 1);

  // Update wings flap
  bird.wingFrame += bird.wingSpeed;

  // Update pipes
  for(let i = pipes.length-1; i>=0; i--) {
    const p = pipes[i];
    p.x -= pipeSpeed;

    if(!p.passed && p.x + pipeWidth < bird.x) {
      p.passed = true;
      p.highlight = true;
      score++;
      updateScore();
      playScoreSound();

      // Create score particles
      for(let j=0; j<10; j++) {
        createParticle(p.x + pipeWidth/2, p.topHeight + pipeGap/2, '#FFD700');
      }
      setTimeout(() => p.highlight = false, 150);
    }

    if(p.x + pipeWidth < 0) pipes.splice(i,1);
  }

  // Add new pipes periodically
  if(frames % 90 === 0) addPipe();

  // Update clouds
  clouds.forEach(c => {
    c.x -= c.speed;
    if(c.x + c.radius < 0) {
      c.x = canvas.width + c.radius;
      c.y = randRange(40, 130);
      c.radius = randRange(30,55);
      c.speed = randRange(0.3,0.8);
    }
  });

  updateParticles();
  checkCollisions();
}

function drawCloud(c) {
  const baseX = c.x;
  const baseY = c.y;
  ctx.fillStyle = 'rgba(255, 255, 255, 0.85)';
  ctx.shadowColor = '#fff';
  ctx.shadowBlur = 10;

  ctx.beginPath();
  for(let i=0; i<5; i++) {
    const offsetX = (i - 2) * c.radius * 0.4;
    const offsetY = Math.sin(i * 2 + frames * 0.05) * c.radius * 0.1;
    const radius = c.radius * (0.4 + Math.sin(i + frames * 0.1) * 0.15);
    ctx.moveTo(baseX + offsetX + radius, baseY + offsetY);
    ctx.arc(baseX + offsetX, baseY + offsetY, radius, 0, Math.PI*2);
  }
  ctx.fill();
  ctx.shadowBlur = 0;
}

// --- Drawing ---
// (drawBackground, drawGround, drawPipes, drawBird functions unchanged, skip for brevity...)

function drawBackground() {
  // Sky gradient
  const skyGrad = ctx.createLinearGradient(0,0,0,canvas.height);
  skyGrad.addColorStop(0, '#87CEEB');
  skyGrad.addColorStop(0.4, '#B0E0E6');
  skyGrad.addColorStop(1, '#90EE90');
  ctx.fillStyle = skyGrad;
  ctx.fillRect(0,0,canvas.width, canvas.height - groundHeight);

  // Clouds
  clouds.forEach(drawCloud);
}
function drawGround() {
  const groundY = canvas.height - groundHeight;
  const groundGrad = ctx.createLinearGradient(0,groundY,0,canvas.height);
  groundGrad.addColorStop(0, '#74a04b');
  groundGrad.addColorStop(0.5, '#5d7a2f');
  groundGrad.addColorStop(1, '#3f4a12');
  ctx.fillStyle = groundGrad;
  ctx.fillRect(0, groundY, canvas.width, groundHeight);
  ctx.fillStyle = '#91c67e';
  for(let x = groundOffset % 20; x < canvas.width; x += 20) {
    ctx.fillRect(x, groundY + 10, 2, 15);
    ctx.fillRect(x + 5, groundY + 10, 2, 10);
    ctx.fillRect(x + 10, groundY + 10, 2, 13);
  }
}
function drawPipes() {
  pipes.forEach(pipe => {
    if(pipe.highlight) {
      ctx.shadowColor = '#ffe066';
      ctx.shadowBlur = 18;
    } else {
      ctx.shadowBlur = 0;
    }
    const grad = ctx.createLinearGradient(pipe.x, 0, pipe.x + pipeWidth, 0);
    grad.addColorStop(0, '#3e8e41');
    grad.addColorStop(0.5, '#2f6a2a');
    grad.addColorStop(1, '#1f4b19');
    ctx.fillStyle = grad;
    ctx.fillRect(pipe.x, 0, pipeWidth, pipe.topHeight);
    ctx.fillRect(pipe.x, pipe.bottomY, pipeWidth, pipe.bottomHeight);
    const capGrad = ctx.createLinearGradient(pipe.x, 0, pipe.x + pipeWidth, 0);
    capGrad.addColorStop(0, '#a8d18d');
    capGrad.addColorStop(0.5, '#6fb33f');
    capGrad.addColorStop(1, '#4a7c21');
    ctx.fillStyle = capGrad;
    ctx.fillRect(pipe.x - 5, pipe.topHeight - 25, pipeWidth + 10, 25);
    ctx.fillRect(pipe.x - 5, pipe.bottomY, pipeWidth + 10, 25);
    ctx.fillStyle = 'rgba(255,255,255,0.3)';
    ctx.fillRect(pipe.x + 4, 0, 5, pipe.topHeight);
    ctx.fillRect(pipe.x + 4, pipe.bottomY, 5, pipe.bottomHeight);
    ctx.shadowBlur = 0;
  });
}
// drawBird function remains unchanged as in your code.

function drawBird() {
  // ... (copy your full drawBird implementation here unchanged)
  // To keep this snippet readable, use the drawBird code from your original code above!
  // (All rendering code for the bird goes here)
  // ----
  // (see your code above)
  // ----
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawBackground();
  drawPipes();
  drawBird();
  drawGround();
  drawParticles();
}

function gameLoop() {
  update();
  draw();
  requestAnimationFrame(gameLoop);
}

initClouds();
// Do not call resetGame here; wait for start

// --- UI Controls ---

// Start Button
startBtn.onclick = () => {
  startScreen.classList.add('hidden');
  resetGame();
  gameState = 'playing';
  scoreEl.style.visibility = "visible";
  canvas.focus();
};

// Restart Button
restartBtn.onclick = () => {
  gameOverScreen.classList.add('hidden');
  resetGame();
  scoreEl.style.visibility = "visible";
  canvas.focus();
};

// Keyboard
window.addEventListener('keydown', e => {
  if(gameState==='start') {
    if(e.code === 'Space' || e.code === 'Enter' || e.code === 'ArrowUp') {
      startScreen.classList.add('hidden');
      resetGame();
      gameState = 'playing';
      scoreEl.style.visibility = "visible";
    }
    return;
  }
  if(e.code === 'Space' || e.code === 'ArrowUp') {
    if(gameState === 'playing') {
      flap();
    } else if(gameState === 'gameOver') {
      gameOverScreen.classList.add('hidden');
      resetGame();
      scoreEl.style.visibility = "visible";
    }
  }
  if(e.code === 'KeyR') {
    if(gameState === 'playing' || gameState === 'gameOver') {
      gameOverScreen.classList.add('hidden');
      resetGame();
      scoreEl.style.visibility = "visible";
    }
  }
});

// Mouse/tap control
canvas.addEventListener('click', () => {
  if(gameState==='start') {
    startScreen.classList.add('hidden');
    resetGame();
    gameState = 'playing';
    scoreEl.style.visibility = "visible";
    return;
  }
  if(gameState === 'playing') flap();
  else if(gameState === 'gameOver') {
    gameOverScreen.classList.add('hidden');
    resetGame();
    scoreEl.style.visibility = "visible";
  }
});

gameLoop();

</script>
</body>
</html>
